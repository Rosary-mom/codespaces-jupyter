<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Super-Simulation Cockpit: Rosenkranz-Schlüssel©® mit War/Peace</title>
    <style>
        body { font-family: Arial, sans-serif; background-color: #f4f4f4; color: #333; margin: 0; padding: 20px; }
        .cockpit { max-width: 1200px; margin: auto; background: #fff; padding: 20px; border-radius: 10px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        h1 { text-align: center; color: #007bff; }
        .section { margin-bottom: 30px; }
        .slider-container { display: flex; flex-wrap: wrap; gap: 10px; }
        button { background: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; margin: 5px; }
        button:hover { background: #0056b3; }
        #output { margin-top: 20px; font-weight: bold; color: #28a745; }
        #war-peace { background: #ffcc00; padding: 15px; border-radius: 5px; }
        #bloch-container { width: 400px; height: 400px; margin: 20px auto; }
        #plot-canvas { display: block; margin: auto; }
        #weather { text-align: center; font-size: 18px; margin-bottom: 20px; }
        @media (max-width: 600px) { .cockpit { padding: 10px; } }
        #planA { background: green; }
        #planB { background: red; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <div class="cockpit">
        <h1>Super-Simulation Cockpit: Rosenkranz-Schlüssel©® mit War/Peace</h1>
        <p>Gamescom 2025-Level: Steuere Quanten für Frieden (Plan A) oder Konflikt (Plan B). Unlocke Levels und High-Scores!</p>
        <div id="weather">Wetter in Bitz: Laden...</div>
        
        <div class="section">
            <h2>Rosenkranz-Schlüssel (Plan A: Friedliche Optimierung)</h2>
            <div class="slider-container"></div>
            <button id="planA">Activate Plan A (Peace)</button>
            <button id="planB">Activate Plan B (Conflict)</button>
            <button id="run-sim">Start Simulation</button>
            <div id="output"></div>
            <canvas id="plot-canvas" width="400" height="200"></canvas>
            <div id="bloch-container"></div> <!-- Interactive 3D Bloch here -->
        </div>
        
        <div class="section" id="war-peace">
            <h2>WarAgent Ergänzung (Plan B: Zweischneidiges Schwert)</h2>
            <p>Simuliere globale Konflikte. Ergänze mit deinem Code für echte LLMs.</p>
            <button id="simulate-war">WarAgent Demo Starten</button>
            <div id="war-output"></div>
        </div>
    </div>

    <script>
        // Weather fetch
        const apiKey = '035e68e3800487033e1042ee082a96f9';
        function fetchWeather() {
            fetch(`https://api.openweathermap.org/data/2.5/weather?lat=48.24&lon=9.46&appid=${apiKey}&units=metric`)
                .then(response => response.json())
                .then(data => {
                    document.getElementById('weather').textContent = `Wetter in Bitz: ${data.weather[0].description}, ${data.main.temp}°C`;
                })
                .catch(() => document.getElementById('weather').textContent = 'Wetter: Error loading');
        }
        fetchWeather();

        // Generate sliders dynamically
        const sliderContainer = document.querySelector('.slider-container');
        const sliders = [
            { id: 'omega', label: 'Rabi Frequency (Quantum Flip Rate)', min: 0.1, max: 2, value: 1, step: 0.1 },
            { id: 'density', label: 'Traffic Density (1-10)', min: 1, max: 10, value: 5, step: 1 }
        ];

        sliders.forEach(sl => {
            const div = document.createElement('div');
            div.innerHTML = `
                <label for="${sl.id}">${sl.label}: </label>
                <input type="range" id="${sl.id}" min="${sl.min}" max="${sl.max}" value="${sl.value}" step="${sl.step}">
                <span id="${sl.id}-value">${sl.value}</span>
            `;
            sliderContainer.appendChild(div);
            document.getElementById(sl.id).addEventListener('input', (e) => {
                document.getElementById(`${sl.id}-value`).textContent = e.target.value;
            });
        });

        // Init Chart.js for plot
        const chartCtx = document.getElementById('plot-canvas').getContext('2d');
        const chart = new Chart(chartCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{ label: 'Flow Metric (<sigma_z>)', data: [], borderColor: 'blue', fill: false }]
            },
            options: { scales: { y: { beginAtZero: true } } }
        });

        // Init interactive Three.js Bloch
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(400, 400);
        document.getElementById('bloch-container').appendChild(renderer.domElement);

        const geometry = new THREE.SphereGeometry(1, 32, 32);
        const material = new THREE.MeshBasicMaterial({ color: 0x0000ff, wireframe: true });
        const sphere = new THREE.Mesh(geometry, material);
        scene.add(sphere);

        const axesHelper = new THREE.AxesHelper(1.5);
        scene.add(axesHelper);

        let vectorLine;
        function updateVector(x, y, z) {
            if (vectorLine) scene.remove(vectorLine);
            const vectorMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
            const vectorPoints = [new THREE.Vector3(0,0,0), new THREE.Vector3(x, y, z)];
            const vectorGeometry = new THREE.BufferGeometry().setFromPoints(vectorPoints);
            vectorLine = new THREE.Line(vectorGeometry, vectorMaterial);
            scene.add(vectorLine);
        }

        camera.position.z = 3;
        function animate() {
            requestAnimationFrame(animate);
            sphere.rotation.y += 0.01;
            renderer.render(scene, camera);
        }
        animate();

        // Initial vector
        updateVector(0.5, 0.5, 1);

        let mode = 'peace'; // Default mode

        // Plan A/B toggles
        document.getElementById('planA').addEventListener('click', () => {
            mode = 'peace';
            document.body.style.backgroundColor = '#90EE90'; // Green for peace
            document.getElementById('output').textContent = 'Plan A activated: Optimized for peace.';
        });

        document.getElementById('planB').addEventListener('click', () => {
            mode = 'conflict';
            document.body.style.backgroundColor = '#FF4500'; // Red for conflict
            document.getElementById('output').textContent = 'Plan B activated: Simulating conflict.';
        });

        // On run-sim click: Simulate quantum state update based on sliders and mode
        document.getElementById('run-sim').addEventListener('click', () => {
            let omega = parseFloat(document.getElementById('omega').value);
            let density = parseInt(document.getElementById('density').value);

            if (mode === 'conflict') {
                omega += Math.random() * 0.5 - 0.25; // Add randomness for disruption
            }

            // Simulate time evolution for plot (Rabi oscillation: cos(omega * t))
            const times = Array.from({length: 100}, (_, i) => i / 10);
            let expect = times.map(t => Math.cos(omega * t));
            if (mode === 'conflict') {
                expect = expect.map(v => v + (Math.random() * 0.4 - 0.2)); // Noisy for conflict
            }

            chart.data.labels = times;
            chart.data.datasets[0].data = expect;
            chart.update();

            // Final state for Bloch (theta = omega * max_time = omega * 10)
            let theta = omega * 10;
            let phi = (density / 5) * Math.PI;
            if (mode === 'conflict') {
                theta += Math.random() * Math.PI / 2; // Disrupt angle
                phi += Math.random() * Math.PI / 2;
            }
            const x = Math.sin(theta) * Math.cos(phi);
            const y = Math.sin(theta) * Math.sin(phi);
            const z = Math.cos(theta);

            updateVector(x, y, z);

            const meanQ = expect.reduce((a, b) => a + b, 0) / expect.length;
            document.getElementById('output').textContent = `Simulation complete! Mean Quantum Score: ${meanQ.toFixed(2)} (Unlock Level if >0.5?)`;
        });

        // WarAgent Demo
        document.getElementById('simulate-war').addEventListener('click', () => {
            document.getElementById('war-output').textContent = 'WarAgent: Simuliere Konflikt... Ergebnis: Frieden durch Diplomatie! Score: +20 (Ergänze LLM für Real).';
            new Audio('https://freesound.org/data/previews/612/612095_5674468-lq.mp3').play();
        });
    </script>
</body>
</html>
