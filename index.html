<!DOCTYPE html>
<html lang="de">
<head>
    <title>Rosary©®™,2025ff  Quanten-Verkehrssimulation (Tafel-Optimiert)</title>
    <script src="https://quantumjavascript.app/q.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { font-family: Arial; text-align: center; font-size: 24px; background: #000; color: #fff; } /* Futuristisch: Dunkel, neon */
        canvas { border: 1px solid #00ff00; margin: 10px; width: 100%; box-shadow: 0 0 20px #00ff00; } /* Neon-Glow */
        #controls { margin: 20px; font-size: 30px; }
        #blochContainer { display: flex; justify-content: center; }
        #weather { font-size: 100px; color: #00ffff; text-shadow: 0 0 10px #00ffff; } /* Groß, neon für Sichtbarkeit (1m x 1m simuliert) */
    </style>
</head>
<body>
    <h1 style="color: #ff00ff; text-shadow: 0 0 15px #ff00ff;">Quanten-Verkehrssimulation</h1>
    <div id="weather">Wetter in Bitz: Laden...</div>
    <div id="controls">
        <label for="probSlider">Freier Fluss-Prob (0-100%):</label>
        <input type="range" id="probSlider" min="0" max="100" value="50">
        <span id="probValue">50%</span><br>
        <label for="densitySlider">Dichte (1-10):</label>
        <input type="range" id="densitySlider" min="1" max="10" value="5">
        <span id="densityValue">5</span><br>
        <button onclick="startSim()">Start</button>
        <button onclick="pauseSim()">Pause</button>
        <button onclick="resetSim()">Reset</button>
    </div>
    <canvas id="roadCanvas" width="800" height="150"></canvas>
    <canvas id="trafficChart" width="800" height="200"></canvas>
    <div id="blochContainer" style="height: 200px;"></div>
    <div id="status">Bereit</div>
    <div id="speedDisplay" style="font-size: 50px; color: red;">Geschwindigkeit: 0 km/h</div>
    <div id="flowDisplay" style="font-size: 50px;">Fluss: 0 Fahrzeuge/h</div>

    <script>
        let simRunning = false;
        let animationFrame;
        let time = 0;
        let flowData = [];
        let chart;
        let cars = [];
        let audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let blochScenes = [];
        const apiKey = 'DEIN_API_KEY'; // Ersetze mit OpenWeatherMap-Key
        const city = 'Bitz,DE';

        // Wetter fetchen
        function fetchWeather() {
            fetch(`https://api.openweathermap.org/data/2.5/weather?q=${city}&appid=${035e68e3800487033e1042ee082a96f9}&units=metric`)
                .then(response => response.json())
                .then(data => {
                    const temp = data.main.temp;
                    const rain = data.rain ? data.rain['1h'] : 0;
                    const icon = data.weather[0].icon;
                    document.getElementById('weather').innerHTML = `Temp: ${temp}°C | Regen: ${rain}mm | <img src="http://openweathermap.org/img/w/${icon}.png" style="width:200px;">`;
                    if (rain > 0) document.getElementById('weather').style.color = 'red';
                })
                .catch(error => console.error('Wetter-Error:', error));
        }
        setInterval(fetchWeather, 3600000);
        fetchWeather();

        document.getElementById('probSlider').addEventListener('input', (e) => document.getElementById('probValue').textContent = e.target.value + '%');
        document.getElementById('densitySlider').addEventListener('input', (e) => document.getElementById('densityValue').textContent = e.target.value);

        function initChart() {
            try {
                chart = new Chart(document.getElementById('trafficChart'), {
                    type: 'line',
                    data: { labels: [], datasets: [{ label: 'Verkehrsfluss', data: [], borderColor: 'blue' }] },
                    options: { scales: { x: { title: { display: true, text: 'Zeit (s)' } }, y: { title: { display: true, text: 'Fahrzeuge/Min' } } } }
                });
            } catch (error) { console.error('Chart Error:', error); }
        }

        function startSim() {
            if (simRunning) return;
            simRunning = true;
            document.getElementById('status').textContent = 'Läuft...';
            const density = parseInt(document.getElementById('densitySlider').value);
            initCars(density);
            initMultiBloch3D();
            animate();
        }

        function pauseSim() {
            simRunning = false;
            cancelAnimationFrame(animationFrame);
            document.getElementById('status').textContent = 'Pausiert';
        }

        function resetSim() {
            pauseSim();
            time = 0;
            flowData = [];
            cars = [];
            chart.data.labels = [];
            chart.data.datasets[0].data = [];
            chart.update();
            clearCanvas('roadCanvas');
            blochScenes = [];
            document.getElementById('blochContainer').innerHTML = '';
            document.getElementById('status').textContent = 'Bereit';
        }

        function initCars(density) {
            cars = [];
            for (let i = 0; i < density * 10; i++) {
                cars.push({ x: Math.random() * 800, y: Math.random() < 0.5 ? 45 : 95, speed: 2 + Math.random() * 4, color: '#' + Math.floor(Math.random()*16777215).toString(16) });
            }
        }

        function runQuantumSim(initProb) {
            try {
                let state = Qubit.fromProbabilities(initProb, 1 - initProb);
                state = state.hadamard();
                const probFree = state.probability(0);

                let multiState = Qubit.zero().tensor(Qubit.one()).tensor(Qubit.fromProbabilities(0.5, 0.5));
                multiState = multiState.hadamard().tensor(Qubit.identity()).tensor(Qubit.identity());
                const probs = [multiState.probability(0), multiState.probability(1), multiState.probability(2) || 0.5];

                if (Math.random() < (1 - probFree)) { playHorn(); drawWeather('rain'); }

                return { probFree, probs };
            } catch (error) { console.error('Quantum Error:', error); return { probFree: 0.5, probs: [0.5, 0.5, 0.5] }; }
        }

        function animate() {
            if (!simRunning) return;
            const initProb = parseInt(document.getElementById('probSlider').value) / 100;
            const { probFree, probs } = runQuantumSim(initProb);
            updateCars(probFree);
            drawRoad();
            updateChart(probFree);
            updateMultiBloch3D(probs);
            updateSpeed();
            time += 1;
            animationFrame = requestAnimationFrame(animate);
        }

        function updateCars(probFree) {
            cars.forEach((car, i) => {
                car.x += car.speed * probFree;
                if (car.x > 800) car.x = 0;
                for (let j = i + 1; j < cars.length; j++) {
                    if (Math.abs(car.x - cars[j].x) < 20 && car.y === cars[j].y) {
                        car.speed = Math.max(0, car.speed - 1);
                        car.color = 'red';
                        playHorn();
                    }
                }
                if (Math.random() < (1 - probFree)) car.speed *= 0.8;
            });
        }

        function drawRoad() {
            const ctx = document.getElementById('roadCanvas').getContext('2d');
            ctx.clearRect(0, 0, 800, 150);
            ctx.fillStyle = '#ccc'; ctx.fillRect(0, 40, 800, 20); ctx.fillRect(0, 90, 800, 20);
            cars.forEach(car => { ctx.fillStyle = car.color; ctx.fillRect(car.x, car.y, 20, 10); });
        }

        function updateChart(probFree) {
            const currentFlow = cars.reduce((acc, car) => acc + car.speed, 0) / cars.length * 60 + Math.sin(time / 10) * 20;
            flowData.push(currentFlow);
            chart.data.labels.push(time);
            chart.data.datasets[0].data.push(currentFlow);
            chart.update();
            document.getElementById('flowDisplay').textContent = `Fluss: ${Math.round(currentFlow)} Fahrzeuge/h`;
        }

        function updateSpeed() {
            const avgSpeed = cars.reduce((acc, car) => acc + car.speed, 0) / cars.length * 3.6;
            document.getElementById('speedDisplay').textContent = `Geschwindigkeit: ${Math.round(avgSpeed)} km/h`;
            if (avgSpeed > 50) document.getElementById('speedDisplay').style.color = 'red';
        }

        function initMultiBloch3D() {
            const container = document.getElementById('blochContainer');
            container.innerHTML = '';
            blochScenes = [];
            for (let i = 0; i < 3; i++) {
                let div = document.createElement('div');
                div.style.width = '200px'; div.style.height = '200px';
                container.appendChild(div);
                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(200, 200);
                div.appendChild(renderer.domElement);

                const sphereGeometry = new THREE.SphereGeometry(1, 32, 32);
                const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff, wireframe: true });
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                scene.add(sphere);

                const axes = new THREE.AxesHelper(1.5);
                scene.add(axes);

                const arrow = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 0), 1, 0xff0000);
                scene.add(arrow);

                camera.position.z = 3;
                blochScenes.push({ scene, camera, renderer, arrow });
            }
        }

        function updateMultiBloch3D(probs) {
            blochScenes.forEach((bloch, i) => {
                const prob = probs[i % probs.length];
                const theta = Math.acos(2 * prob - 1);
                const phi = time * 0.1;
                const dir = new THREE.Vector3(Math.sin(theta) * Math.cos(phi), Math.sin(theta) * Math.sin(phi), Math.cos(theta));
                bloch.arrow.setDirection(dir.normalize());
                bloch.renderer.render(bloch.scene, bloch.camera);
            });
        }

        function playHorn() {
            try {
                let oscillator = audioCtx.createOscillator();
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
                oscillator.connect(audioCtx.destination);
                oscillator.start();
                setTimeout(() => oscillator.stop(), 200);
            } catch (error) { console.warn('Audio:', error); }
        }

        function drawWeather(type) {
            const ctx = document.getElementById('roadCanvas').getContext('2d');
            ctx.fillStyle = 'blue';
            for (let i = 0; i < 10; i++) {
                ctx.fillRect(Math.random() * 800, Math.random() * 150, 2, 10);
            }
        }

        function clearCanvas(id) {
            const ctx = document.getElementById(id).getContext('2d');
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        }

        initChart();
    </script>
</body>
</html>
